#!/usr/bin/env python3
"""
SAM8905 memory analyzer for Keyfox10
Parses the D-RAM and A-RAM log files generated by MAME
"""

import re
from pathlib import Path

MAME_DIR = Path("/home/jeff/bastel/mame/mame")

def parse_sam_log(filepath):
    """Parse a SAM memory log file"""
    data = {}
    current_slot = None

    with open(filepath) as f:
        for line in f:
            # Match slot header
            m = re.match(r'Slot (\d+):', line)
            if m:
                current_slot = int(m.group(1))
                continue

            # Match data line: [XX] S.WW = 0xVVVVV (DDDDD)
            m = re.match(r'\s+\[([0-9A-F]+)\]\s+(\d+)\.(\d+)\s+=\s+0x([0-9A-F]+)', line)
            if m:
                addr = int(m.group(1), 16)
                slot = int(m.group(2))
                word = int(m.group(3))
                value = int(m.group(4), 16)
                data[addr] = {"slot": slot, "word": word, "value": value}

    return data

def analyze_dram(data, chip_name):
    """Analyze D-RAM contents (16 slots × 16 words × 19 bits)"""
    print(f"\n{'='*60}")
    print(f"D-RAM Analysis: {chip_name}")
    print(f"{'='*60}")

    # Count non-zero entries
    non_zero = {k: v for k, v in data.items() if v["value"] != 0}
    print(f"Non-zero entries: {len(non_zero)} / 256")

    # Analyze by slot
    print("\nSlot summary (non-zero entries):")
    for slot in range(16):
        slot_data = {k: v for k, v in data.items() if v["slot"] == slot and v["value"] != 0}
        if slot_data:
            values = [v["value"] for v in slot_data.values()]
            print(f"  Slot {slot:2d}: {len(slot_data)} entries, "
                  f"range 0x{min(values):05X}-0x{max(values):05X}")

    # Check word 15 (often special - end marker?)
    print("\nWord 15 values (often special):")
    for slot in range(16):
        addr = slot * 16 + 15
        if addr in data:
            val = data[addr]["value"]
            if val != 0:
                print(f"  Slot {slot:2d}, word 15: 0x{val:05X} ({val})")

def disasm_aram_instruction(value):
    """Disassemble a single 15-bit A-RAM micro-instruction.

    Format (from ELRAD 1990):
      I14-I12: MAD (memory address 0-7, selects D-RAM word)
      I11-I10: CMD (00=RM, 01=RADD, 10=RP, 11=RSP)
      I09: WSP (special modifier - changes receiver behavior)
      I08: WA (write register A from bus)
      I07: WB (write register B from bus)
      I06: WM (write D-RAM[MAD] from bus)
      I05: WPHI (write PHI register from bus upper 12 bits)
      I04: WXY (load X from sine/sample, Y from bus, also MIXL/MIXR)
      I03: clearB (clear register B to 0)
      I02: WWF (write WF waveform register)
      I01-I00: WACC (0=none, 1-3=add to output accumulator)

    Commands:
      RM   - Read Memory: put D-RAM[MAD] on internal bus
      RADD - Read ADDer: put A+B result on bus
      RP   - Read Product: put X*Y multiplier result on bus
      RSP  - Read Stack Pointer: NOP, used for wait cycles
    """
    mad = (value >> 12) & 0x7
    cmd = (value >> 10) & 0x3
    wsp = (value >> 9) & 0x1
    wa = (value >> 8) & 0x1
    wb = (value >> 7) & 0x1
    wm = (value >> 6) & 0x1
    wphi = (value >> 5) & 0x1
    wxy = (value >> 4) & 0x1
    clearb = (value >> 3) & 0x1
    wwf = (value >> 2) & 0x1
    wacc = value & 0x3

    cmd_names = ["RM", "RADD", "RP", "RSP"]
    cmd_str = cmd_names[cmd]

    # Build receiver list in assembler syntax style
    receivers = []
    if wsp: receivers.append("WSP")
    if wa: receivers.append("WA")
    if wb: receivers.append("WB")
    if wm: receivers.append("WM")
    if wphi: receivers.append("WPHI")
    if wxy: receivers.append("WXY")
    if clearb: receivers.append("clrB")
    if wwf: receivers.append("WWF")
    if wacc: receivers.append(f"WACC")

    # Format like assembler: CMD MAD, <receivers>
    if cmd == 3:  # RSP = NOP
        if receivers:
            recv_str = ",<" + ",".join(receivers) + ">"
        else:
            recv_str = ",,"  # NOP with no receivers = pure wait
        disasm = f"RSP  {recv_str}"
    else:
        recv_str = ",<" + ",".join(receivers) + ">" if receivers else ""
        disasm = f"{cmd_str:4s} M{mad}{recv_str}"

    # Add semantic comment
    comment = get_instruction_comment(cmd, mad, wsp, wa, wb, wm, wphi, wxy, clearb, wwf, wacc)

    return disasm, comment


def get_instruction_comment(cmd, mad, wsp, wa, wb, wm, wphi, wxy, clearb, wwf, wacc):
    """Generate a semantic comment explaining what the instruction does."""
    parts = []

    # D-RAM word names (generic - actual meaning depends on algorithm)
    # Common conventions: M0=PHI, M1=DPHI, M2=AMP, but these are just labels
    dram_names = {}

    if cmd == 0:  # RM - Read Memory
        name = dram_names.get(mad, f"D{mad}")
        parts.append(f"bus=D-RAM[{name}]")
    elif cmd == 1:  # RADD - Read Adder
        parts.append("bus=A+B")
    elif cmd == 2:  # RP - Read Product
        parts.append("bus=X*Y")
    elif cmd == 3:  # RSP - NOP
        if not any([wa, wb, wm, wphi, wxy, clearb, wwf, wacc]):
            return "wait"

    # Receiver effects
    if wa and wphi and wsp:
        parts.append("A=bus, PHI=bus[18:7], sel_sine")
    elif wa and wphi:
        parts.append("A=bus, PHI=bus[18:7]")
    elif wa:
        parts.append("A=bus")

    if wb:
        parts.append("B=bus")

    if wm:
        name = dram_names.get(mad, f"D{mad}")
        if wsp:
            parts.append(f"D-RAM[{name}]=bus (cond)")
        else:
            parts.append(f"D-RAM[{name}]=bus")

    if wphi and not wa:
        if wsp:
            parts.append("PHI=bus, sel_sine")
        else:
            parts.append("PHI=bus[18:7]")

    if wxy:
        if wsp:
            parts.append("X=sin(PHI), Y=bus[18:7], set_pan")
        else:
            parts.append("X=sin(PHI), Y=bus[18:7]")

    if clearb:
        parts.append("B=0")

    if wwf:
        parts.append("WF=bus[17:9]")

    if wacc:
        parts.append(f"ACC+=X*Y")

    return "; ".join(parts) if parts else ""


def disasm_aram(data, chip_name):
    """Disassemble A-RAM contents as micro-instructions (8 slots × 32 words)"""
    print(f"\n{'='*80}")
    print(f"A-RAM Disassembly: {chip_name}")
    print(f"{'='*80}")

    # 44kHz mode: 8 slots × 32 words
    for slot in range(8):
        start = slot * 32
        end = start + 32

        # Check if slot has any non-zero values
        slot_data = {k: v for k, v in data.items()
                     if start <= k < end and v["value"] != 0}
        if not slot_data:
            continue

        print(f"\nAlgorithm {slot}:")
        print("-" * 80)
        for word in range(32):
            addr = start + word
            if addr in data:
                val = data[addr]["value"]
                disasm, comment = disasm_aram_instruction(val)
                if comment:
                    print(f"  [{word:02d}] 0x{val:04X}  {disasm:32s} ; {comment}")
                else:
                    print(f"  [{word:02d}] 0x{val:04X}  {disasm}")


def analyze_aram(data, chip_name):
    """Analyze A-RAM contents (8 slots × 32 words × 15 bits for 44kHz)"""
    print(f"\n{'='*60}")
    print(f"A-RAM Analysis: {chip_name}")
    print(f"{'='*60}")

    # Count non-zero entries
    non_zero = {k: v for k, v in data.items() if v["value"] != 0}
    print(f"Non-zero entries: {len(non_zero)} / 256")

    # Analyze by slot (44kHz mode: 8 slots × 32 words)
    print("\nSlot summary (44kHz mode - 8 slots × 32 words):")
    for slot in range(8):
        start = slot * 32
        end = start + 32
        slot_data = {k: v for k, v in data.items()
                     if start <= k < end and v["value"] != 0}
        if slot_data:
            values = [v["value"] for v in slot_data.values()]
            print(f"  Slot {slot}: {len(slot_data):2d}/32 entries, "
                  f"range 0x{min(values):04X}-0x{max(values):04X}")

    # Show first slot waveform data
    print("\nSlot 0 waveform (first 32 words):")
    for word in range(32):
        if word in data:
            val = data[word]["value"]
            bar_len = val * 40 // 0x7FFF if val > 0 else 0
            bar = '█' * bar_len
            print(f"  [{word:02d}] 0x{val:04X} {bar}")

def main():
    chips = [
        ("SND", "sam_snd"),
        ("FX", "sam_fx")
    ]

    for chip_name, prefix in chips:
        # D-RAM
        dram_file = MAME_DIR / f"{prefix}_dram.log"
        if dram_file.exists():
            dram_data = parse_sam_log(dram_file)
            analyze_dram(dram_data, chip_name)

        # A-RAM
        aram_file = MAME_DIR / f"{prefix}_aram.log"
        if aram_file.exists():
            aram_data = parse_sam_log(aram_file)
            analyze_aram(aram_data, chip_name)
            disasm_aram(aram_data, chip_name)

if __name__ == "__main__":
    main()
