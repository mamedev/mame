# FX SRAM 2-Byte Storage Hypothesis

## Background

The Keyfox10 FX chip (SAM8905) uses an 8-bit SRAM (IC19, 32KB) for delay/reverb buffers.
The SAM8905 expects 12-bit waveform data, but the SRAM only provides 8 bits.

## Hardware Connections (from schematic)

### SRAM Data Bus

| SRAM256 Pin | SAM8905 Pin | Notes |
|-------------|-------------|-------|
| D0          | WDH3        | SRAM bit 0 → SAM bit 3 |
| D1          | WDH4        | |
| D2          | WDH5        | |
| D3          | WDH6        | |
| D4          | WDH7        | |
| D5          | WDH8        | |
| D6          | WDH9        | |
| D7          | WDH10       | SRAM bit 7 → SAM bit 10 |
| -           | WD0-WD2     | Pulled to GND via 1k resistors |
| -           | WD11        | Generated by logic |

### WD11 Logic (IC9 74HC00)

```
WDH11 = ~NAND(~WAH0, WDH10) = (~WAH0) AND WDH10
```

- **WAH0=0:** WDH11 = WDH10 (sign extension from bit 10)
- **WAH0=1:** WDH11 = 0 (forced low)

## Hypothesis: 2-Byte Storage

### Why 2-Byte Storage Makes Sense

1. **Sign extension logic depends on WAH0** - Why would the hardware need address-dependent
   sign extension if not for distinguishing high/low bytes?

2. **Timing allows it** - With 709ns per instruction and 70ns SRAM access time,
   there's 10x margin for two SRAM reads per waveform access.

3. **Algorithm doesn't show paired accesses** - If 2-byte is automatic in hardware,
   the algorithm wouldn't need to explicitly access even/odd pairs.

4. **Similar to SND input** - The audio input from SND chip uses two shift registers,
   suggesting a pattern of serialized multi-byte data.

### Proposed Data Format

```
Even address (WAH0=0): HIGH byte
  - Stores bits 11:4 of 12-bit sample
  - Sign extension: WD11 = WD10 (bit 7 of SRAM copied to bit 11)

Odd address (WAH0=1): LOW byte
  - Stores bits 3:0 of 12-bit sample (in upper nibble?)
  - WD11 = 0 (don't care, overwritten by high byte)
```

### Hardware Sequence (hypothetical)

1. SAM issues waveform read with 15-bit address A
2. Hardware reads SRAM[A & ~1] (even address)
   - Gets D7:D0 at WD10:WD3
   - WD11 = D7 (sign extension, since WAH0=0)
   - This is HIGH byte: bits 11:4
3. Hardware reads SRAM[A | 1] (odd address)
   - Gets D7:D0 at WD10:WD3
   - WD11 = 0 (since WAH0=1)
   - This is LOW byte: bits 3:0 in D7:D4?
4. Hardware combines into 12-bit value and returns to SAM

### Capacity

- **1-byte storage:** 32K samples (current assumption)
- **2-byte storage:** 16K samples (if hypothesis is correct)

## Evidence Summary

### Supporting Evidence

1. WAH0-dependent WD11 logic has no other obvious purpose
2. Ample timing margin for 2 reads per SAM cycle
3. All analyzed algorithm addresses have WAH0=0 (no explicit odd access)
4. Similar 2-byte pattern used for SND→FX audio input

### Questions to Resolve

1. Is there sequencing logic in IC9/IC10 that cycles WAH0?
2. How exactly are the two bytes combined (byte order, bit positions)?
3. Does the write path also use 2-byte storage?

## Alternative: 1-Byte Storage

If only single-byte storage:
- SRAM stores 8-bit samples directly
- Data appears at WD10:WD3, sign-extended to WD11 when WAH0=0
- WD2:WD0 always 0 (grounded)
- Resolution: 8 bits per sample
- Capacity: 32K samples

This is simpler but doesn't explain the WAH0-dependent sign extension logic.

## Files

- `fx_sram_analysis.py` - Analysis code for waveform access patterns
- `fx_sram_hypothesis.md` - This document

## Next Steps

1. Examine schematic more closely for sequencing logic around IC9/IC10
2. Check if there's a flip-flop or counter that toggles during SRAM access
3. Look at actual SRAM read/write timing on oscilloscope (if hardware available)
4. Try implementing 2-byte storage in emulator and compare audio output
