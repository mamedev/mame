// license:BSD-3-Clause
// copyright-holders:Nicola Salmoria
#include "emu.h"
#include "cclimber.h"

// set to 1 to fix protection check after bonus round (see notes in pacman.c driver)
#define CANNONB_HACK    0

void cclimber_state::cclimber_decode(const uint8_t convtable[8][16])
{
	uint8_t *rom = memregion("maincpu")->base();

	for (int A = 0x0000;A < 0x6000;A++)
	{
		int i,j;
		uint8_t src = rom[A];

		// pick the translation table from bit 0 of the address
		// and from bits 1 7 of the source data
		i = (A & 1) | (src & 0x02) | ((src & 0x80) >> 5);

		// pick the offset in the table from bits 0 2 4 6 of the source data
		j = (src & 0x01) | ((src & 0x04) >> 1) | ((src & 0x10) >> 2) | ((src & 0x40) >> 3);

		// decode the opcodes
		m_decrypted_opcodes[A] = (src & 0xaa) | convtable[i][j];
	}
}

void cclimber_state::init_cclimber()
{
	static const uint8_t convtable[8][16] =
	{
		// 0xff marks spots which are unused and therefore unknown
		{ 0x44,0x14,0x54,0x10,0x11,0x41,0x05,0x50,0x51,0x00,0x40,0x55,0x45,0x04,0x01,0x15 },
		{ 0x44,0x10,0x15,0x55,0x00,0x41,0x40,0x51,0x14,0x45,0x11,0x50,0x01,0x54,0x04,0x05 },
		{ 0x45,0x10,0x11,0x44,0x05,0x50,0x51,0x04,0x41,0x14,0x15,0x40,0x01,0x54,0x55,0x00 },
		{ 0x04,0x51,0x45,0x00,0x44,0x10,0xff,0x55,0x11,0x54,0x50,0x40,0x05,0xff,0x14,0x01 },
		{ 0x54,0x51,0x15,0x45,0x44,0x01,0x11,0x41,0x04,0x55,0x50,0xff,0x00,0x10,0x40,0xff },
		{ 0xff,0x54,0x14,0x50,0x51,0x01,0xff,0x40,0x41,0x10,0x00,0x55,0x05,0x44,0x11,0x45 },
		{ 0x51,0x04,0x10,0xff,0x50,0x40,0x00,0xff,0x41,0x01,0x05,0x15,0x11,0x14,0x44,0x54 },
		{ 0xff,0xff,0x54,0x01,0x15,0x40,0x45,0x41,0x51,0x04,0x50,0x05,0x11,0x44,0x10,0x14 }
	};

	cclimber_decode(convtable);
}

void cclimber_state::init_cclimberj()
{
	static const uint8_t convtable[8][16] =
	{
		{ 0x41,0x54,0x51,0x14,0x05,0x10,0x01,0x55,0x44,0x11,0x00,0x50,0x15,0x40,0x04,0x45 },
		{ 0x50,0x11,0x40,0x55,0x51,0x14,0x45,0x04,0x54,0x15,0x10,0x05,0x44,0x01,0x00,0x41 },
		{ 0x44,0x11,0x00,0x50,0x41,0x54,0x04,0x14,0x15,0x40,0x51,0x55,0x05,0x10,0x01,0x45 },
		{ 0x10,0x50,0x54,0x55,0x01,0x44,0x40,0x04,0x14,0x11,0x00,0x41,0x45,0x15,0x51,0x05 },
		{ 0x14,0x41,0x01,0x44,0x04,0x50,0x51,0x45,0x11,0x40,0x54,0x15,0x10,0x00,0x55,0x05 },
		{ 0x01,0x05,0x41,0x45,0x54,0x50,0x55,0x10,0x11,0x15,0x51,0x14,0x44,0x40,0x04,0x00 },
		{ 0x05,0x55,0x00,0x50,0x11,0x40,0x54,0x14,0x45,0x51,0x10,0x04,0x44,0x01,0x41,0x15 },
		{ 0x55,0x50,0x15,0x10,0x01,0x04,0x41,0x44,0x45,0x40,0x05,0x00,0x11,0x14,0x51,0x54 },
	};

	cclimber_decode(convtable);
}

void cclimber_state::init_ckongb()
{
	uint8_t *rom = memregion("maincpu")->base();

	for (int A = 0x0000; A < 0x6000; A++) // all the program ROMs are encrypted
	{
		rom[A] = rom[A] ^ 0xf0;
	}
}

#if CANNONB_HACK
void ::cannonb_patch()
{
	uint8_t *rom = memregion("maincpu")->base();

	rom[0x2ba0] = 0x21;
	rom[0x2ba1] = 0xfb;
	rom[0x2ba2] = 0x0e;
	rom[0x2ba3] = 0x00;
}
#endif

void cclimber_state::init_cannonb()
{
	uint8_t *rom = memregion("maincpu")->base();

	for (int A = 0x0000; A < 0x1000; A++) // only first ROM is encrypted
	{
		uint8_t src;
		int i;
		static const uint8_t xor_tab[4] ={0x92, 0x82, 0x12, 0x10};

		src = rom[A+0x10000];

		i = ((A&0x200)>>8) | ((A&0x80)>>7);

		src ^= xor_tab[i];

		rom[A] = src;
	}

#if CANNONB_HACK
	cannonb_patch(machine());
#endif
}

void cclimber_state::init_cannonb2()
{
#if CANNONB_HACK
	cannonb_patch(machine());
#endif
}
